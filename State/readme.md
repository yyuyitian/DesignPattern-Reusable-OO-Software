#  适用性
1. 一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变他的行为
2. 一个状态包含庞大的多分支的条件语句，通常多个操作包含这一相同的条件结构。State模式将每一个条件分支放入一个独立的类中。这使得你可以根据对象自身的情况将对象的状态作为一个对象，这一对象不依赖于其他对象而独立变化。

#  参与者

1. Context（环境，如 TCPConnection)

   一定义客户感兴趣的接口。

   一维护一个 Concretestate 子类的实例，这个实例定义当前状态。

2. State（状态，如 TCPState)

   一定义一个接口以封装与 Context 的一个特定状态相关的行为。

3. Concrete State subclasses（具体状态子类，如 TCPEstablished、TCPListen、TCP Closed)

   一每一于类实现一个与 Context 的一个状态相关的行为。

#  协作

1. Context 将与状态相关的请求委托给当前的 ConcreteState 对象处理。
2. Context 可将自身作为一个参数传递给处理该请求的状态对象。这使得状态对象在必要时可访问 Context
3. Context 是客户使用的主要接口。客户可用状态对象来配置一个Context，一旦一个Context 配置完毕，它的客户不再需要直接与状态对象打交道。
4. Context 或 ConcreteState子类都可决定哪个状态是另外一个的后继者，以及是在何种条件下进行状态转换。

#  效果
1. 将与特定状态相关的行为局部化，并且将不同状态的行为分隔开。决定状态转移的逻辑不在单块的if或者switch语句当中，而是分布在State子类之间。将每一个状态转化和动作封装到一个类中，就把着眼点从执行状态提高到整个对象的状态。这将使得代码结构化并使得意图更加清晰。
2. 使得状态转换显式化。State对象可以保证Context不会内部状态不一致的情况，因为从Context的角度来看，状态转换是原子的，只需要重新绑定一个变量，而无需为多个变量赋值。

